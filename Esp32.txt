#include <Wire.h>
#include <WiFi.h>
#include <WiFiUdp.h>

#define I2C_SLAVE_ADDR 0x04
#define SERIAL_BAUD 9600

// ====== WiFi (CAMBIA ESTO) ======
const char* SSID = "9D74C5";
const char* PASS = "286032354";

// ====== Destino ROS2 (tu VM) ======
IPAddress ROS_IP(192, 168, 1, 76);
const uint16_t ROS_PORT = 5005;

WiFiUDP udp;

volatile bool dataReady = false;
volatile uint8_t foundFlag = 0;
volatile uint8_t cx = 0;
volatile uint8_t cy = 0;

// Se ejecuta cuando el maestro (Arduino) envía datos por I2C
void onReceiveI2C(int len) {
  if (len >= 3) {
    foundFlag = Wire.read(); // 1 = encontrado, 0 = no
    cx        = Wire.read(); // X
    cy        = Wire.read(); // Y
    dataReady = true;
  }

  // Limpiar bytes extra si llegan
  while (Wire.available()) {
    Wire.read();
  }
}

void connectWiFi() {
  Serial.print("Conectando a WiFi: ");
  Serial.println(SSID);

  WiFi.mode(WIFI_STA);
  WiFi.begin(SSID, PASS);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("\nWiFi OK");
  Serial.print("IP ESP32: ");
  Serial.println(WiFi.localIP());
}

void sendUdpToRos(uint8_t found, uint8_t x, uint8_t y, uint8_t shape) {
  char msg[32];
  // Formato esperado por tu nodo ROS: found,cx,cy,shape
  snprintf(msg, sizeof(msg), "%u,%u,%u,%u\n", found, x, y, shape);

  udp.beginPacket(ROS_IP, ROS_PORT);
  udp.write((uint8_t*)msg, strlen(msg));
  udp.endPacket();

  Serial.print("Enviado UDP -> ");
  Serial.print(msg);
}

void setup() {
  Serial.begin(SERIAL_BAUD);
  delay(200);

  Serial.println("ESP32 I2C esclavo + UDP a ROS");

  // Conectar WiFi
  connectWiFi();

  // Iniciar ESP32 como esclavo I2C
  Wire.begin(I2C_SLAVE_ADDR);
  Wire.onReceive(onReceiveI2C);

  Serial.println("Esperando coordenadas por I2C...");
}

void loop() {
  // Si se cayó WiFi, intenta reconectar
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi desconectado, reconectando...");
    connectWiFi();
  }

  if (dataReady) {
    // Copiar variables "volatile" a locales de forma segura
    uint8_t f, x, y;
    noInterrupts();
    f = foundFlag;
    x = cx;
    y = cy;
    dataReady = false;
    interrupts();

    // Imprimir lo recibido por I2C
    Serial.print("Recibido I2C -> found=");
    Serial.print(f);
    Serial.print(" cx=");
    Serial.print(x);
    Serial.print(" cy=");
    Serial.println(y);

    // Enviar a ROS por UDP (shape=0 por ahora)
    sendUdpToRos(f, x, y, 0);
  }
}
