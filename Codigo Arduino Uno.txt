//Este código funciona con el código de notropic
#include <TVout.h>
#include <fontALL.h>
#include <Wire.h>

#define W 128
#define H 96
#define I2C_SLAVE_ADDR 0x04   // Dirección del ESP32 esclavo (debe coincidir)
#define I2C_HZ 100000         // 100 kHz

TVout tv;
unsigned char x, y;
unsigned char c;
unsigned char minX, minY, maxX, maxY;
char s[32];

void sendI2C4(uint8_t foundFlag, uint8_t cx, uint8_t cy, uint8_t shape) {
  Wire.beginTransmission(I2C_SLAVE_ADDR);
  Wire.write(foundFlag); // 1 byte
  Wire.write(cx);        // 1 byte
  Wire.write(cy);        // 1 byte
  Wire.write(shape);     // 1 byte
  Wire.endTransmission();
}

void setup()  {
  tv.begin(NTSC, W, H);
  initOverlay();
  initInputProcessing();

  tv.select_font(font4x6);
  tv.fill(0);

  // I2C master (Arduino UNO)
  Wire.begin();
  Wire.setClock(I2C_HZ);
}

void initOverlay() {
  TCCR1A = 0;
  // Enable timer1. ICES0 is set to 0 for falling edge detection on input capture pin.
  TCCR1B = _BV(CS10);

  // Enable input capture interrupt
  TIMSK1 |= _BV(ICIE1);

  // Enable external interrupt INT0 on pin 2 with falling edge.
  EIMSK = _BV(INT0);
  EICRA = _BV(ISC01);
}

void initInputProcessing() {
  // Analog Comparator setup
  ADCSRA &= ~_BV(ADEN); // disable ADC
  ADCSRB |= _BV(ACME);  // enable ADC multiplexer
  ADMUX &= ~_BV(MUX0);  // select A2 for use as AIN1 (negative voltage of comparator)
  ADMUX |= _BV(MUX1);
  ADMUX &= ~_BV(MUX2);
  ACSR &= ~_BV(ACIE);   // disable analog comparator interrupts
  ACSR &= ~_BV(ACIC);   // disable analog comparator input capture
}

// Required
ISR(INT0_vect) {
  display.scanLine = 0;
}

void loop() {
  tv.capture();

  // compute bounding box
  minX = W;
  minY = H;
  maxX = 0;
  maxY = 0;
  boolean found = 0;

  for (int y = 0; y < H; y++) {
    for (int x = 0; x < W; x++) {
      c = tv.get_pixel(x, y);
      if (c == 1) {
        found = true;
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }
    }
  }

  // draw bounding box + show coords
  tv.fill(0);

  uint8_t cx = 0;
  uint8_t cy = 0;

  if (found) {
    tv.draw_line(minX, minY, maxX, minY, 1);
    tv.draw_line(minX, minY, minX, maxY, 1);
    tv.draw_line(maxX, minY, maxX, maxY, 1);
    tv.draw_line(minX, maxY, maxX, maxY, 1);

    cx = (uint8_t)((maxX + minX) / 2);
    cy = (uint8_t)((maxY + minY) / 2);

    sprintf(s, "%d, %d", cx, cy);
    tv.print(0, 0, s);

    // Enviar a ESP32: found=1, cx, cy, shape=0
    sendI2C4(1, cx, cy, 0);
  } else {
    tv.print(0, 0, "not found");

    // Enviar a ESP32: found=0, cx=0, cy=0, shape=0
    sendI2C4(0, 0, 0, 0);
  }

  tv.resume();
  tv.delay_frame(5);
}
